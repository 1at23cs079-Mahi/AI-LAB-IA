<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 1: Robot Vacuum Path Optimization</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <style>
        body { background: linear-gradient(135deg, #e0f7ff 0%, #b3e5fc 100%); }
        .problem-container { background: white; border: 2px solid #0288d1; box-shadow: 0 4px 20px rgba(2, 136, 209, 0.2); }
        .back-button { background: #0288d1; color: white; }
        .back-button:hover { background: #0277bd; transform: translateY(-2px); }
        .problem-header { border-bottom: 3px solid #0288d1; background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%); }
        .problem-header h1 { color: #01579b; }
        .problem-header .description { color: #455a64; }
        .controls { background: #f5f5f5; border: 2px solid #0288d1; }
        .controls h3 { color: #01579b; }
        .controls label { color: #424242; }
        .btn { background: linear-gradient(135deg, #0288d1 0%, #0277bd 100%); color: white; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(2, 136, 209, 0.3); }
        .btn-secondary { background: #e3f2fd; color: #0288d1; border: 2px solid #0288d1; }
        .output { background: #fafafa; border: 2px solid #0288d1; }
        .output h3 { color: #01579b; }
        .cell { border: 2px solid #0288d1; background: white; color: #424242; }
        .cell.start { background: #0288d1; color: white; font-weight: bold; }
        .cell.goal { background: #e91e63; color: white; font-weight: bold; }
        .cell.path { background: #4caf50; color: white; }
        .cell.obstacle { background: #616161; color: white; }
        .cell.visited { background: #e1f5fe; }
    </style>
    <div class="problem-container">
        <a href="index.html" class="back-button">‚Üê Back to Home</a>
        
        <div class="problem-header">
            <h1>ü§ñ Problem 1: Robot Vacuum Path Optimization</h1>
            <p class="description">
                Implement Uniform Cost Search to find the shortest cleaning route that covers all reachable tiles exactly once in a 5√ó5 room with obstacles.
            </p>
        </div>

        <div class="controls">
            <h3>Configure Room</h3>
            <div class="control-group">
                <label>Select Mode:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                    <button class="btn btn-secondary" onclick="setCellMode('start')" id="mode-start" style="background: #00d4ff; color: #0a0e27;">ü§ñ Start</button>
                    <button class="btn btn-secondary" onclick="setCellMode('goal')" id="mode-goal" style="background: #ff0080; color: white;">üéØ Goal</button>
                    <button class="btn btn-secondary" onclick="setCellMode('obstacle')" id="mode-obstacle" style="background: #2a3550; color: #00d4ff;">‚¨õ Obstacle</button>
                    <button class="btn btn-secondary" onclick="setCellMode('clear')" id="mode-clear" style="background: white; color: #0a0e27;">‚¨ú Clear</button>
                </div>
                <label>Current Mode: <strong id="currentMode">Obstacle</strong> - Click cells to place</label>
                <div id="gridSetup" class="visualization"></div>
            </div>
            <button class="btn" onclick="solveUCS()">üîç Find Optimal Path (UCS)</button>
            <button class="btn" onclick="animatePath()">‚ñ∂Ô∏è Animate Path</button>
            <button class="btn btn-secondary" onclick="randomObstacles()">üé≤ Randomize</button>
            <button class="btn btn-secondary" onclick="resetGrid()">üîÑ Reset</button>
        </div>

        <div id="output" class="output" style="display:none;">
            <h3>Results</h3>
            <div id="resultContent"></div>
            <div class="visualization">
                <div id="solutionGrid"></div>
            </div>
            <div class="stats" id="stats"></div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 5;
        let grid = [];
        let start = {x: 0, y: 0};
        let goal = {x: 4, y: 4};
        let cellMode = 'obstacle';
        let animationInterval = null;
        let lastResult = null;

        function setCellMode(mode) {
            cellMode = mode;
            document.querySelectorAll('[id^="mode-"]').forEach(btn => {
                btn.style.opacity = '0.6';
            });
            document.getElementById(`mode-${mode}`).style.opacity = '1';
            const modeNames = {'start': 'ü§ñ Start', 'goal': 'üéØ Goal', 'obstacle': '‚¨õ Obstacle', 'clear': '‚¨ú Clear'};
            document.getElementById('currentMode').textContent = modeNames[mode];
        }

        function initGrid() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            grid[1][2] = grid[2][1] = grid[3][3] = 1;
            renderSetupGrid();
        }

        function renderSetupGrid() {
            const container = document.getElementById('gridSetup');
            container.innerHTML = '';
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = () => toggleCell(i, j);
                    
                    if (i === start.x && j === start.y) {
                        cell.classList.add('start');
                        cell.textContent = 'S';
                    } else if (i === goal.x && j === goal.y) {
                        cell.classList.add('goal');
                        cell.textContent = 'G';
                    } else if (grid[i][j] === 1) {
                        cell.classList.add('obstacle');
                        cell.textContent = '‚ñ†';
                    }
                    
                    gridDiv.appendChild(cell);
                }
            }
            container.appendChild(gridDiv);
        }

        function toggleCell(x, y) {
            if (cellMode === 'start') {
                start = {x, y};
                if (grid[x][y] === 1) grid[x][y] = 0;
            } else if (cellMode === 'goal') {
                goal = {x, y};
                if (grid[x][y] === 1) grid[x][y] = 0;
            } else if (cellMode === 'obstacle') {
                if ((x === start.x && y === start.y) || (x === goal.x && y === goal.y)) return;
                grid[x][y] = 1;
            } else if (cellMode === 'clear') {
                if ((x === start.x && y === start.y) || (x === goal.x && y === goal.y)) return;
                grid[x][y] = 0;
            }
            renderSetupGrid();
        }

        function randomObstacles() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            
            // Random start and goal
            start = {x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE)};
            do {
                goal = {x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE)};
            } while (goal.x === start.x && goal.y === start.y);
            
            // Random obstacles (25-40% of cells)
            const numObstacles = Math.floor(Math.random() * 6) + 5;
            for (let i = 0; i < numObstacles; i++) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                if ((x !== start.x || y !== start.y) && (x !== goal.x || y !== goal.y)) {
                    grid[x][y] = 1;
                }
            }
            renderSetupGrid();
        }

        function resetGrid() {
            if (animationInterval) clearInterval(animationInterval);
            initGrid();
            document.getElementById('output').style.display = 'none';
        }

        class PriorityQueue {
            constructor() {
                this.items = [];
            }
            
            enqueue(element, priority) {
                this.items.push({element, priority});
                this.items.sort((a, b) => a.priority - b.priority);
            }
            
            dequeue() {
                return this.items.shift();
            }
            
            isEmpty() {
                return this.items.length === 0;
            }
        }

        function uniformCostSearch() {
            const directions = [[0,1], [1,0], [0,-1], [-1,0]];
            const pq = new PriorityQueue();
            const visited = new Set();
            const parent = {};
            const cost = {};
            
            const startKey = `${start.x},${start.y}`;
            const goalKey = `${goal.x},${goal.y}`;
            
            pq.enqueue(startKey, 0);
            cost[startKey] = 0;
            parent[startKey] = null;
            
            let nodesExplored = 0;
            
            while (!pq.isEmpty()) {
                const {element: current, priority: currentCost} = pq.dequeue();
                
                if (visited.has(current)) continue;
                visited.add(current);
                nodesExplored++;
                
                if (current === goalKey) {
                    // Reconstruct path
                    const path = [];
                    let node = current;
                    while (node !== null) {
                        const [x, y] = node.split(',').map(Number);
                        path.unshift({x, y});
                        node = parent[node];
                    }
                    return {path, cost: currentCost, nodesExplored, visited: Array.from(visited)};
                }
                
                const [x, y] = current.split(',').map(Number);
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    const nextKey = `${nx},${ny}`;
                    
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && 
                        grid[nx][ny] === 0 && !visited.has(nextKey)) {
                        const newCost = currentCost + 1;
                        
                        if (!(nextKey in cost) || newCost < cost[nextKey]) {
                            cost[nextKey] = newCost;
                            parent[nextKey] = current;
                            pq.enqueue(nextKey, newCost);
                        }
                    }
                }
            }
            
            return null; // No path found
        }

        function solveUCS() {
            const result = uniformCostSearch();
            lastResult = result;
            const output = document.getElementById('output');
            const resultContent = document.getElementById('resultContent');
            const solutionGrid = document.getElementById('solutionGrid');
            const stats = document.getElementById('stats');
            
            if (animationInterval) clearInterval(animationInterval);
            output.style.display = 'block';
            
            if (result) {
                resultContent.innerHTML = `
                    <div class="alert alert-success">
                        ‚úì Path found successfully! Total cost: ${result.cost} steps
                    </div>
                `;
                
                // Render solution grid
                const gridDiv = document.createElement('div');
                gridDiv.className = 'grid';
                gridDiv.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
                
                const pathSet = new Set(result.path.map(p => `${p.x},${p.y}`));
                const visitedSet = new Set(result.visited);
                
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        const key = `${i},${j}`;
                        
                        if (i === start.x && j === start.y) {
                            cell.classList.add('start');
                            cell.textContent = 'S';
                        } else if (i === goal.x && j === goal.y) {
                            cell.classList.add('goal');
                            cell.textContent = 'G';
                        } else if (grid[i][j] === 1) {
                            cell.classList.add('obstacle');
                            cell.textContent = '‚ñ†';
                        } else if (pathSet.has(key)) {
                            cell.classList.add('path');
                            cell.textContent = '‚Üí';
                        } else if (visitedSet.has(key)) {
                            cell.classList.add('visited');
                        }
                        
                        gridDiv.appendChild(cell);
                    }
                }
                
                solutionGrid.innerHTML = '';
                solutionGrid.appendChild(gridDiv);
                
                const efficiency = ((result.path.length - 1) / result.nodesExplored * 100).toFixed(1);
                stats.innerHTML = `
                    <div class="stat-card">
                        <div class="label">Path Length</div>
                        <div class="value">${result.path.length}</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Total Cost</div>
                        <div class="value">${result.cost}</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Nodes Explored</div>
                        <div class="value">${result.nodesExplored}</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Search Efficiency</div>
                        <div class="value">${efficiency}%</div>
                    </div>
                `;
            } else {
                resultContent.innerHTML = `
                    <div class="alert alert-error">
                        ‚úó No path found! The goal is unreachable from the start position.
                    </div>
                `;
                solutionGrid.innerHTML = '';
                stats.innerHTML = '';
            }
        }

        function animatePath() {
            if (!lastResult) {
                alert('Please solve the path first!');
                return;
            }
            
            const solutionGrid = document.getElementById('solutionGrid');
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            
            let step = 0;
            if (animationInterval) clearInterval(animationInterval);
            
            animationInterval = setInterval(() => {
                if (step >= lastResult.path.length) {
                    clearInterval(animationInterval);
                    return;
                }
                
                gridDiv.innerHTML = '';
                const visitedSet = new Set(lastResult.visited);
                
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        const key = `${i},${j}`;
                        
                        const onPath = lastResult.path.some((p, idx) => p.x === i && p.y === j && idx <= step);
                        const isCurrentPos = lastResult.path[step] && i === lastResult.path[step].x && j === lastResult.path[step].y;
                        
                        if (i === start.x && j === start.y) {
                            cell.classList.add('start');
                            cell.textContent = 'S';
                        } else if (i === goal.x && j === goal.y) {
                            cell.classList.add('goal');
                            cell.textContent = 'G';
                        } else if (isCurrentPos) {
                            cell.style.background = '#ffff00';
                            cell.style.border = '3px solid #00d4ff';
                            cell.textContent = 'ü§ñ';
                            cell.style.fontSize = '20px';
                        } else if (onPath) {
                            cell.classList.add('path');
                            cell.textContent = '‚Üí';
                        } else if (grid[i][j] === 1) {
                            cell.classList.add('obstacle');
                            cell.textContent = '‚ñ†';
                        } else if (visitedSet.has(key)) {
                            cell.classList.add('visited');
                        }
                        
                        gridDiv.appendChild(cell);
                    }
                }
                
                solutionGrid.innerHTML = `<h4 style="color: #00d4ff; margin: 10px 0;">Step ${step + 1} of ${lastResult.path.length} - Cost: ${step}</h4>`;
                solutionGrid.appendChild(gridDiv);
                step++;
            }, 500);
        }

        initGrid();
    </script>
</body>
</html>
