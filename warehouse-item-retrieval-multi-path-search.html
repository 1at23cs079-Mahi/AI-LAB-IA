<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 4: Warehouse Item Retrieval (Multi-Path Search)</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <style>
        body { background: linear-gradient(135deg, #fff8e1 0%, #fff9c4 100%); }
        .problem-container { background: white; color: #424242; border: 3px solid #f57f17; box-shadow: 0 10px 30px rgba(245, 127, 23, 0.15); border-radius: 12px; }
        .back-button { background: #f57f17; color: white; font-weight: bold; border-radius: 8px; }
        .back-button:hover { background: #f9a825; transform: translateY(-2px); }
        .problem-header { border-bottom: 4px solid #f57f17; background: linear-gradient(135deg, #fffde7 0%, #fff9c4 100%); }
        .problem-header h1 { color: #f57f17; font-family: 'Courier New', monospace; }
        .problem-header .description { color: #616161; }
        .controls { background: #fafafa; border: 2px solid #f57f17; border-radius: 12px; }
        .controls h3 { color: #f57f17; text-transform: uppercase; font-family: 'Courier New', monospace; }
        .controls label { color: #424242; }
        .btn { background: #f57f17; color: white; border-radius: 8px; font-weight: bold; }
        .btn:hover { background: #f9a825; transform: scale(1.05); }
        .btn-secondary { background: #fff9c4; color: #f57f17; border: 2px solid #f57f17; }
        .output { background: #fafafa; border: 3px solid #f57f17; color: #424242; border-radius: 12px; }
        .cell { background: white; border: 2px solid #f57f17; color: #424242; display:flex; align-items:center; justify-content:center; border-radius:8px; transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; }
        .cell:hover { transform: translateY(-1px); }
        .visualization { background: white; border: 2px solid #f57f17; border-radius: 12px; padding: 10px; }
        .grid { display: grid; gap: 6px; padding: 8px; background: linear-gradient(135deg, #fffef5 0%, #fff8e6 100%); border-radius: 12px; }
        .legend { display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; }
        .legend-item { display:flex; align-items:center; gap:6px; background:#fffde7; border:1px dashed #f57f17; padding:6px 10px; border-radius:8px; font-size: 13px; }
        .legend-dot { width:18px; height:18px; border-radius:4px; border:2px solid #f57f17; display:inline-block; }
        .badge { padding:4px 8px; border-radius:12px; font-size:12px; border:1px solid #f57f17; background:#fff3cd; color:#8a6d3b; }

        @keyframes pulse-soft {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245, 127, 23, 0.25); }
            70% { transform: scale(1.02); box-shadow: 0 0 0 10px rgba(245, 127, 23, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(245, 127, 23, 0); }
        }
    </style>
    <div class="problem-container">
        <a href="batch-b1.html" class="back-button">‚Üê Back to Batch B1</a>
        
        <div class="problem-header">
            <h1>üì¶ Problem 4: Warehouse Item Retrieval (Multi-Path Search)</h1>
            <p class="description">
                Compare A* vs Greedy Best-First Search for picking three items from different racks and returning to base.
            </p>
        </div>

        <div class="controls">
            <h3>Warehouse Configuration</h3>
            <div class="control-group">
                <label>Click on grid to set: Base (B), Items (1,2,3), Obstacles (X)</label>
                <div id="gridSetup" class="visualization"></div>
            </div>
            <button class="btn" onclick="solveAStar()">Solve with A*</button>
            <button class="btn" onclick="solveGreedy()">Solve with Greedy Best-First</button>
            <button class="btn" onclick="solveDijkstra()">Solve with Dijkstra</button>
            <button class="btn" onclick="compareAlgorithms()">Compare Both</button>
            <button class="btn btn-secondary" onclick="randomizeWarehouse()">üé≤ Randomize</button>
            <button class="btn btn-secondary" onclick="resetWarehouse()">Reset</button>

            <div class="control-group" style="margin-top:15px; display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:14px;">
                <label><input type="checkbox" id="showExplored" checked> Show Explored Nodes</label>
                <label><input type="checkbox" id="animateToggle" checked> Animate Path</label>
                <label>Speed: <input id="speedSlider" type="range" min="20" max="300" step="10" value="80"> <span id="speedLabel">80ms</span></label>
                <label>Cell Size: <input id="cellSizeSlider" type="range" min="24" max="64" step="4" value="40"> <span id="cellSizeLabel">40px</span></label>
            </div>
            <div class="legend">
                <div class="legend-item"><span class="legend-dot" style="background:#3498db; border-color:#1f6fa1"></span> Base (B)</div>
                <div class="legend-item"><span class="legend-dot" style="background:#f39c12; border-color:#b06f0b"></span> Items 1-3</div>
                <div class="legend-item"><span class="legend-dot" style="background:#7f8c8d; border-color:#5c6a6b"></span> Obstacle (X)</div>
                <div class="legend-item"><span class="legend-dot" style="background:#2ecc71; border-color:#1d9c52"></span> A* Path</div>
                <div class="legend-item"><span class="legend-dot" style="background:#9b59b6; border-color:#6f3f82"></span> Greedy Path</div>
                <div class="legend-item"><span class="legend-dot" style="background:#1abc9c; border-color:#148f77"></span> Dijkstra Path</div>
                <div class="legend-item"><span class="legend-dot" style="background:#bbdefb; border-color:#90caf9"></span> A* Explored</div>
                <div class="legend-item"><span class="legend-dot" style="background:#e1bee7; border-color:#ce93d8"></span> Greedy Explored</div>
                <div class="legend-item"><span class="legend-dot" style="background:#b2dfdb; border-color:#80cbc4"></span> Dijkstra Explored</div>
            </div>
        </div>

        <div id="output" class="output" style="display:none;">
            <h3>Results</h3>
            <div id="resultContent"></div>
            <div class="visualization">
                <div id="solutionGrid"></div>
            </div>
            <div class="stats" id="stats"></div>
        </div>
    </div>

    <script>
        const SIZE = 8;
        let grid = [];
        let base = {x: 0, y: 0};
        let items = [{x: 2, y: 5}, {x: 5, y: 2}, {x: 7, y: 6}];
        let mode = 'obstacle';

        // UI helpers
        const getShowExplored = () => (document.getElementById('showExplored')?.checked ?? true);
        const getAnimate = () => (document.getElementById('animateToggle')?.checked ?? true);
        const getSpeed = () => parseInt(document.getElementById('speedSlider')?.value || '80', 10);
        const getCellSize = () => parseInt(document.getElementById('cellSizeSlider')?.value || '40', 10);

        function initUIControls() {
            const speedSlider = document.getElementById('speedSlider');
            const speedLabel = document.getElementById('speedLabel');
            const cellSizeSlider = document.getElementById('cellSizeSlider');
            const cellSizeLabel = document.getElementById('cellSizeLabel');
            if (speedSlider && speedLabel) {
                speedLabel.textContent = `${speedSlider.value}ms`;
                speedSlider.oninput = () => speedLabel.textContent = `${speedSlider.value}ms`;
            }
            if (cellSizeSlider && cellSizeLabel) {
                cellSizeLabel.textContent = `${cellSizeSlider.value}px`;
                cellSizeSlider.oninput = () => { cellSizeLabel.textContent = `${cellSizeSlider.value}px`; renderGrid(); };
            }
        }

        function initGrid() {
            grid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
            grid[2][3] = grid[4][4] = grid[5][1] = grid[6][5] = 1; // Obstacles
            renderGrid();
        }

        function renderGrid() {
            const container = document.getElementById('gridSetup');
            container.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <button class="btn" style="padding: 5px 10px;" onclick="mode='base'">Set Base (B)</button>
                    <button class="btn" style="padding: 5px 10px;" onclick="mode='item1'">Set Item 1</button>
                    <button class="btn" style="padding: 5px 10px;" onclick="mode='item2'">Set Item 2</button>
                    <button class="btn" style="padding: 5px 10px;" onclick="mode='item3'">Set Item 3</button>
                    <button class="btn btn-secondary" style="padding: 5px 10px;" onclick="mode='obstacle'">Toggle Obstacle</button>
                </div>
            `;
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    const sz = getCellSize();
                    cell.style.width = `${sz}px`;
                    cell.style.height = `${sz}px`;
                    cell.setAttribute('data-pos', `${i},${j}`);
                    cell.onclick = () => handleCellClick(i, j);
                    
                    if (i === base.x && j === base.y) {
                        cell.style.background = '#3498db';
                        cell.textContent = 'üè†';
                        cell.style.fontSize = '18px';
                        cell.style.color = 'white';
                        cell.style.boxShadow = '0 6px 14px rgba(52,152,219,0.25)';
                        cell.style.animation = 'pulse-soft 1.8s infinite ease-in-out';
                        cell.title = `Base @ (${i},${j})`;
                    } else {
                        const itemIdx = items.findIndex(it => it.x === i && it.y === j);
                        if (itemIdx !== -1) {
                            cell.style.background = '#f39c12';
                            cell.textContent = 'üì¶';
                            cell.style.fontSize = '18px';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 6px 14px rgba(243,156,18,0.25)';
                            cell.style.animation = 'pulse-soft 2.2s infinite ease-in-out';
                            cell.title = `Item ${itemIdx + 1} @ (${i},${j})`;
                        } else if (grid[i][j] === 1) {
                            cell.classList.add('obstacle');
                            cell.textContent = 'X';
                            cell.style.color = 'white';
                            cell.style.background = 'repeating-linear-gradient(45deg, #7f8c8d, #7f8c8d 8px, #8f9a9b 8px, #8f9a9b 16px)';
                            cell.style.boxShadow = 'inset 0 0 10px rgba(0,0,0,0.1)';
                            cell.title = `Obstacle @ (${i},${j})`;
                        }
                    }
                    
                    gridDiv.appendChild(cell);
                }
            }
            container.appendChild(gridDiv);
        }

        function handleCellClick(x, y) {
            if (mode === 'base') {
                base = {x, y};
            } else if (mode === 'item1') {
                items[0] = {x, y};
            } else if (mode === 'item2') {
                items[1] = {x, y};
            } else if (mode === 'item3') {
                items[2] = {x, y};
            } else {
                grid[x][y] = grid[x][y] === 0 ? 1 : 0;
            }
            renderGrid();
        }

        function manhattan(p1, p2) {
            return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
        }

        function findPath(start, goal, heuristic = 'astar') {
            const pq = [{pos: start, g: 0, h: (heuristic === 'dijkstra' ? 0 : manhattan(start, goal)), path: [start]}];
            const visited = new Set();
            const exploredCells = [];
            let nodesExplored = 0;

            while (pq.length > 0) {
                pq.sort((a, b) => {
                    if (heuristic === 'greedy') return a.h - b.h;
                    if (heuristic === 'dijkstra') return a.g - b.g;
                    return (a.g + a.h) - (b.g + b.h);
                });
                
                const current = pq.shift();
                const key = `${current.pos.x},${current.pos.y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                exploredCells.push({x: current.pos.x, y: current.pos.y});
                nodesExplored++;

                if (current.pos.x === goal.x && current.pos.y === goal.y) {
                    return {path: current.path, cost: current.g, nodesExplored, exploredCells};
                }

                const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
                for (const [dx, dy] of dirs) {
                    const nx = current.pos.x + dx;
                    const ny = current.pos.y + dy;
                    const nkey = `${nx},${ny}`;

                    if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && 
                        grid[nx][ny] === 0 && !visited.has(nkey)) {
                        pq.push({
                            pos: {x: nx, y: ny},
                            g: current.g + 1,
                            h: (heuristic === 'dijkstra' ? 0 : manhattan({x: nx, y: ny}, goal)),
                            path: [...current.path, {x: nx, y: ny}]
                        });
                    }
                }
            }
            return null;
        }

        function solveMultiGoal(heuristic) {
            // Find order: Base -> Item1 -> Item2 -> Item3 -> Base
            const goals = [items[0], items[1], items[2], base];
            let currentPos = base;
            let totalPath = [];
            let totalCost = 0;
            let totalNodes = 0;
            let allExplored = [];

            for (const goal of goals) {
                const result = findPath(currentPos, goal, heuristic);
                if (!result) return null;
                
                totalPath = totalPath.concat(result.path.slice(1));
                totalCost += result.cost;
                totalNodes += result.nodesExplored;
                allExplored = allExplored.concat(result.exploredCells);
                currentPos = goal;
            }

            return {path: [base, ...totalPath], cost: totalCost, nodesExplored: totalNodes, exploredCells: allExplored};
        }

        function solveAStar() {
            const result = solveMultiGoal('astar');
            displayResult(result, 'A* Algorithm');
        }

        function solveGreedy() {
            const result = solveMultiGoal('greedy');
            displayResult(result, 'Greedy Best-First');
        }

        function solveDijkstra() {
            const result = solveMultiGoal('dijkstra');
            displayResult(result, 'Dijkstra');
        }

        function compareAlgorithms() {
            const astar = solveMultiGoal('astar');
            const greedy = solveMultiGoal('greedy');
            const dijkstra = solveMultiGoal('dijkstra');
            
            const output = document.getElementById('output');
            const resultContent = document.getElementById('resultContent');
            const stats = document.getElementById('stats');
            
            output.style.display = 'block';
            
            // Determine overall winner: MOST nodes explored wins (as requested)
            const algs = [
                { name: 'A*', key: 'astar', cost: astar.cost, nodes: astar.nodesExplored },
                { name: 'Greedy', key: 'greedy', cost: greedy.cost, nodes: greedy.nodesExplored },
                { name: 'Dijkstra', key: 'dijkstra', cost: dijkstra.cost, nodes: dijkstra.nodesExplored }
            ];
            const maxNodes = Math.max(...algs.map(a => a.nodes));
            const winners = algs.filter(a => a.nodes === maxNodes).map(a => a.key);

            const winnerMark = (key) => winners.includes(key) ? '‚úì Winner (most nodes)' : '';

            resultContent.innerHTML = `
                <div class="alert alert-success">
                    ‚úì Comparison Complete!
                </div>
                <table>
                    <tr><th>Algorithm</th><th>Path Cost</th><th>Nodes Explored</th><th>Winner (most nodes)</th></tr>
                    <tr>
                        <td>A*</td>
                        <td>${astar.cost}</td>
                        <td>${astar.nodesExplored}</td>
                        <td>${winnerMark('astar')}</td>
                    </tr>
                    <tr>
                        <td>Greedy Best-First</td>
                        <td>${greedy.cost}</td>
                        <td>${greedy.nodesExplored}</td>
                        <td>${winnerMark('greedy')}</td>
                    </tr>
                    <tr>
                        <td>Dijkstra</td>
                        <td>${dijkstra.cost}</td>
                        <td>${dijkstra.nodesExplored}</td>
                        <td>${winnerMark('dijkstra')}</td>
                    </tr>
                </table>
            `;

            stats.innerHTML = `
                <div class="stat-card">
                    <div class="label">A* Cost</div>
                    <div class="value">${astar.cost}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Greedy Cost</div>
                    <div class="value">${greedy.cost}</div>
                </div>
                <div class="stat-card">
                    <div class="label">A* Nodes</div>
                    <div class="value">${astar.nodesExplored}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Greedy Nodes</div>
                    <div class="value">${greedy.nodesExplored}</div>
                </div>
            `;
            
            // Render comparison grids
            const solutionGrid = document.getElementById('solutionGrid');
            solutionGrid.innerHTML = `
                <h4 style="color: #f57f17; margin: 15px 0;">Path Comparison</h4>
                <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #f57f17;">
                    <h5 style="color: #424242; margin-top: 0;">üí° Why Different Nodes Explored?</h5>
                    <p style="color: #616161; margin: 8px 0; font-size: 14px;">
                        <strong style="color: #2ecc71;">A*</strong> uses <strong>g(n) + h(n)</strong> (cost so far + heuristic) ‚Äî systematic and optimal.<br>
                        <strong style="color: #9b59b6;">Greedy</strong> uses <strong>only h(n)</strong> (heuristic to goal) ‚Äî explores fewer nodes, may miss optimal path.<br>
                        <strong style="color: #1abc9c;">Dijkstra</strong> uses <strong>only g(n)</strong> (cost so far) ‚Äî no heuristic, often explores many nodes but guarantees optimal path.
                    </p>
                    <p style="color: #616161; margin: 8px 0; font-size: 14px;">
                        Below: <span style="color: #64b5f6;">Light blue</span>/<span style="color: #ab47bc;">Light purple</span>/<span style="color: #26a69a;">Light teal</span> = explored; <span style="color: #2ecc71;">Green</span>/<span style="color: #9b59b6;">Purple</span>/<span style="color: #1abc9c;">Teal</span> = final paths
                    </p>
                </div>
            `;
            
            // A* Grid
            const astarContainer = document.createElement('div');
            astarContainer.innerHTML = '<h5 style="color: #424242;">A* Path</h5>';
            const astarGrid = document.createElement('div');
            astarGrid.className = 'grid';
            astarGrid.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            
            const astarPathSet = new Set(astar.path.map(p => `${p.x},${p.y}`));
            const astarExploredSet = new Set(astar.exploredCells.map(p => `${p.x},${p.y}`));
            
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    const sz = getCellSize();
                    cell.style.width = `${sz}px`;
                    cell.style.height = `${sz}px`;
                    const key = `${i},${j}`;
                    
                    if (i === base.x && j === base.y) {
                        cell.style.background = '#3498db';
                        cell.textContent = 'üè†';
                        cell.style.fontSize = '18px';
                        cell.style.color = 'white';
                        cell.style.boxShadow = '0 6px 14px rgba(52,152,219,0.25)';
                    } else {
                        const itemIdx = items.findIndex(it => it.x === i && it.y === j);
                        if (itemIdx !== -1) {
                            cell.style.background = '#f39c12';
                            cell.textContent = 'üì¶';
                            cell.style.fontSize = '18px';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 6px 14px rgba(243,156,18,0.25)';
                        } else if (grid[i][j] === 1) {
                            cell.style.background = 'repeating-linear-gradient(45deg, #7f8c8d, #7f8c8d 8px, #8f9a9b 8px, #8f9a9b 16px)';
                            cell.textContent = 'X';
                            cell.style.color = 'white';
                        } else if (astarPathSet.has(key)) {
                            cell.style.background = '#2ecc71';
                            cell.textContent = '‚Üí';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 0 0 2px rgba(46,204,113,0.35), 0 0 12px rgba(46,204,113,0.6)';
                        } else if (astarExploredSet.has(key) && getShowExplored()) {
                            cell.style.background = '#bbdefb';
                            cell.style.color = '#1976d2';
                            cell.style.fontSize = '10px';
                            cell.textContent = '¬∑';
                        }
                    }
                    astarGrid.appendChild(cell);
                }
            }
            astarContainer.appendChild(astarGrid);
            
            // Greedy Grid
            const greedyContainer = document.createElement('div');
            greedyContainer.innerHTML = '<h5 style="color: #424242; margin-top: 20px;">Greedy Best-First Path</h5>';
            const greedyGrid = document.createElement('div');
            greedyGrid.className = 'grid';
            greedyGrid.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            
            const greedyPathSet = new Set(greedy.path.map(p => `${p.x},${p.y}`));
            const greedyExploredSet = new Set(greedy.exploredCells.map(p => `${p.x},${p.y}`));
            
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    const sz2 = getCellSize();
                    cell.style.width = `${sz2}px`;
                    cell.style.height = `${sz2}px`;
                    const key = `${i},${j}`;
                    
                    if (i === base.x && j === base.y) {
                        cell.style.background = '#3498db';
                        cell.textContent = 'üè†';
                        cell.style.fontSize = '18px';
                        cell.style.color = 'white';
                        cell.style.boxShadow = '0 6px 14px rgba(52,152,219,0.25)';
                    } else {
                        const itemIdx = items.findIndex(it => it.x === i && it.y === j);
                        if (itemIdx !== -1) {
                            cell.style.background = '#f39c12';
                            cell.textContent = 'üì¶';
                            cell.style.fontSize = '18px';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 6px 14px rgba(243,156,18,0.25)';
                        } else if (grid[i][j] === 1) {
                            cell.style.background = 'repeating-linear-gradient(45deg, #7f8c8d, #7f8c8d 8px, #8f9a9b 8px, #8f9a9b 16px)';
                            cell.textContent = 'X';
                            cell.style.color = 'white';
                        } else if (greedyPathSet.has(key)) {
                            cell.style.background = '#9b59b6';
                            cell.textContent = '‚Üí';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 0 0 2px rgba(155,89,182,0.35), 0 0 12px rgba(155,89,182,0.6)';
                        } else if (greedyExploredSet.has(key) && getShowExplored()) {
                            cell.style.background = '#e1bee7';
                            cell.style.color = '#7b1fa2';
                            cell.style.fontSize = '10px';
                            cell.textContent = '¬∑';
                        }
                    }
                    greedyGrid.appendChild(cell);
                }
            }
            greedyContainer.appendChild(greedyGrid);
            
            // Dijkstra Grid
            const dijkContainer = document.createElement('div');
            dijkContainer.innerHTML = '<h5 style="color: #424242; margin-top: 20px;">Dijkstra Path</h5>';
            const dijkGrid = document.createElement('div');
            dijkGrid.className = 'grid';
            dijkGrid.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;

            const dijkPathSet = new Set(dijkstra.path.map(p => `${p.x},${p.y}`));
            const dijkExploredSet = new Set(dijkstra.exploredCells.map(p => `${p.x},${p.y}`));

            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    const sz3 = getCellSize();
                    cell.style.width = `${sz3}px`;
                    cell.style.height = `${sz3}px`;
                    const key = `${i},${j}`;

                    if (i === base.x && j === base.y) {
                        cell.style.background = '#3498db';
                        cell.textContent = 'üè†';
                        cell.style.fontSize = '18px';
                        cell.style.color = 'white';
                        cell.style.boxShadow = '0 6px 14px rgba(52,152,219,0.25)';
                    } else {
                        const itemIdx = items.findIndex(it => it.x === i && it.y === j);
                        if (itemIdx !== -1) {
                            cell.style.background = '#f39c12';
                            cell.textContent = 'üì¶';
                            cell.style.fontSize = '18px';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 6px 14px rgba(243,156,18,0.25)';
                        } else if (grid[i][j] === 1) {
                            cell.style.background = 'repeating-linear-gradient(45deg, #7f8c8d, #7f8c8d 8px, #8f9a9b 8px, #8f9a9b 16px)';
                            cell.textContent = 'X';
                            cell.style.color = 'white';
                        } else if (dijkPathSet.has(key)) {
                            cell.style.background = '#1abc9c';
                            cell.textContent = '‚Üí';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 0 0 2px rgba(26,188,156,0.35), 0 0 12px rgba(26,188,156,0.6)';
                        } else if (dijkExploredSet.has(key) && getShowExplored()) {
                            cell.style.background = '#b2dfdb';
                            cell.style.color = '#00695c';
                            cell.style.fontSize = '10px';
                            cell.textContent = '¬∑';
                        }
                    }
                    dijkGrid.appendChild(cell);
                }
            }
            dijkContainer.appendChild(dijkGrid);

            solutionGrid.appendChild(astarContainer);
            solutionGrid.appendChild(greedyContainer);
            solutionGrid.appendChild(dijkContainer);
        }

        function displayResult(result, alg) {
            if (!result) {
                alert('No path found!');
                return;
            }

            const output = document.getElementById('output');
            const resultContent = document.getElementById('resultContent');
            const stats = document.getElementById('stats');
            const solutionGrid = document.getElementById('solutionGrid');
            
            output.style.display = 'block';
            
            resultContent.innerHTML = `<div class="alert alert-success">‚úì ${alg} found path!</div>`;

            stats.innerHTML = `
                <div class="stat-card">
                    <div class="label">Total Cost</div>
                    <div class="value">${result.cost}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Path Length</div>
                    <div class="value">${result.path.length}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Nodes Explored</div>
                    <div class="value">${result.nodesExplored}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Algorithm</div>
                    <div class="value" style="font-size:1.1rem">${alg}</div>
                </div>
            `;

            // Render solution grid with path
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            
            const pathSet = new Set(result.path.map(p => `${p.x},${p.y}`));
            const exploredSet = new Set(result.exploredCells.map(p => `${p.x},${p.y}`));
            const animate = getAnimate();
            const showExplored = getShowExplored();
            const sz = getCellSize();
            const pathCells = [];
            
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = `${sz}px`;
                    cell.style.height = `${sz}px`;
                    const key = `${i},${j}`;
                    
                    if (i === base.x && j === base.y) {
                        cell.style.background = '#3498db';
                        cell.textContent = 'üè†';
                        cell.style.fontSize = '18px';
                        cell.style.color = 'white';
                        cell.style.boxShadow = '0 6px 14px rgba(52,152,219,0.25)';
                    } else {
                        const itemIdx = items.findIndex(it => it.x === i && it.y === j);
                        if (itemIdx !== -1) {
                            cell.style.background = '#f39c12';
                            cell.textContent = 'üì¶';
                            cell.style.fontSize = '18px';
                            cell.style.color = 'white';
                            cell.style.boxShadow = '0 6px 14px rgba(243,156,18,0.25)';
                        } else if (grid[i][j] === 1) {
                            cell.style.background = 'repeating-linear-gradient(45deg, #7f8c8d, #7f8c8d 8px, #8f9a9b 8px, #8f9a9b 16px)';
                            cell.textContent = 'X';
                            cell.style.color = 'white';
                            cell.style.boxShadow = 'inset 0 0 10px rgba(0,0,0,0.1)';
                        } else if (pathSet.has(key)) {
                            if (animate) {
                                // Defer painting; collect for animation
                                pathCells.push({i, j});
                            } else {
                                const isAstar = (alg === 'A*') || alg.includes('A*');
                                const isGreedy = alg.toLowerCase().includes('greedy');
                                const isDijkstra = alg.toLowerCase().includes('dijkstra');
                                const color = isAstar ? '#2ecc71' : (isGreedy ? '#9b59b6' : '#1abc9c');
                                cell.style.background = color;
                                cell.textContent = '‚Üí';
                                cell.style.color = 'white';
                                cell.style.boxShadow = isAstar
                                    ? '0 0 0 2px rgba(46,204,113,0.35), 0 0 12px rgba(46,204,113,0.6)'
                                    : (isGreedy
                                        ? '0 0 0 2px rgba(155,89,182,0.35), 0 0 12px rgba(155,89,182,0.6)'
                                        : '0 0 0 2px rgba(26,188,156,0.35), 0 0 12px rgba(26,188,156,0.6)');
                            }
                        } else if (exploredSet.has(key) && showExplored) {
                            const isAstar = (alg === 'A*') || alg.includes('A*');
                            const isGreedy = alg.toLowerCase().includes('greedy');
                            const isDijkstra = alg.toLowerCase().includes('dijkstra');
                            cell.style.background = isAstar ? '#bbdefb' : (isGreedy ? '#e1bee7' : '#b2dfdb');
                            cell.style.color = isAstar ? '#1976d2' : (isGreedy ? '#7b1fa2' : '#00695c');
                            cell.style.fontSize = '10px';
                            cell.textContent = '¬∑';
                        }
                    }
                    
                    gridDiv.appendChild(cell);
                }
            }
            
            solutionGrid.innerHTML = '';
            solutionGrid.appendChild(gridDiv);

            // Animate path if enabled
            if (animate && pathCells.length > 0) {
                const speed = getSpeed();
                const isAstar = (alg === 'A*') || alg.includes('A*');
                const isGreedy = alg.toLowerCase().includes('greedy');
                const isDijkstra = alg.toLowerCase().includes('dijkstra');
                const color = isAstar ? '#2ecc71' : (isGreedy ? '#9b59b6' : '#1abc9c');
                const cells = Array.from(gridDiv.children);
                const indexOf = (i, j) => i * SIZE + j;
                result.path.forEach((p, idx) => {
                    const el = cells[indexOf(p.x, p.y)];
                    if (!el) return;
                    setTimeout(() => {
                        el.style.background = color;
                        el.style.color = 'white';
                        el.textContent = '‚Üí';
                        el.style.boxShadow = isAstar
                            ? '0 0 0 2px rgba(46,204,113,0.35), 0 0 12px rgba(46,204,113,0.6)'
                            : (isGreedy
                                ? '0 0 0 2px rgba(155,89,182,0.35), 0 0 12px rgba(155,89,182,0.6)'
                                : '0 0 0 2px rgba(26,188,156,0.35), 0 0 12px rgba(26,188,156,0.6)');
                    }, speed * idx);
                });
            }
        }

        function resetWarehouse() {
            initGrid();
            document.getElementById('output').style.display = 'none';
        }

        function randomizeWarehouse() {
            grid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
            
            // Random base position
            base = {x: Math.floor(Math.random() * SIZE), y: Math.floor(Math.random() * SIZE)};
            
            // Random items (ensure they don't overlap)
            items = [];
            for (let i = 0; i < 3; i++) {
                let pos;
                do {
                    pos = {x: Math.floor(Math.random() * SIZE), y: Math.floor(Math.random() * SIZE)};
                } while ((pos.x === base.x && pos.y === base.y) || items.some(it => it.x === pos.x && it.y === pos.y));
                items.push(pos);
            }
            
            // Random obstacles (15-25% of cells)
            const numObstacles = Math.floor(Math.random() * 8) + 8;
            for (let i = 0; i < numObstacles; i++) {
                const x = Math.floor(Math.random() * SIZE);
                const y = Math.floor(Math.random() * SIZE);
                if ((x !== base.x || y !== base.y) && !items.some(it => it.x === x && it.y === y)) {
                    grid[x][y] = 1;
                }
            }
            
            renderGrid();
        }

        initGrid();
        initUIControls();
    </script>
</body>
</html>
