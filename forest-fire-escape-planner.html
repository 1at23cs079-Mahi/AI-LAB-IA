<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problem 5: Forest Fire Escape Planner</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <style>
        body { background: linear-gradient(135deg, #ff0000 0%, #8b0000 100%); animation: pulse 2s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.9; } }
        @keyframes collisionPulse { 0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 255, 0, 0.8); } 50% { transform: scale(1.1); box-shadow: 0 0 40px rgba(255, 255, 0, 1); } }
        .problem-container { background: #1a0000; color: #ffcccc; border: 4px solid #ff4444; box-shadow: 0 0 40px rgba(255, 68, 68, 0.6); }
        .back-button { background: #ff4444; color: white; border-radius: 30px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .back-button:hover { background: #ff0000; box-shadow: 0 0 20px rgba(255, 68, 68, 0.8); }
        .problem-header { border-bottom: 3px solid #ff4444; background: linear-gradient(135deg, #330000 0%, #1a0000 100%); }
        .problem-header h1 { color: #ff6666; text-shadow: 0 0 10px rgba(255, 102, 102, 0.5); }
        .problem-header p { color: #ffcccc !important; }
        .controls { background: #330000; border: 2px solid #ff4444; }
        .controls h3 { color: #ffeeee !important; text-shadow: 0 0 5px rgba(255, 238, 238, 0.5); }
        .controls label { color: #ffdddd !important; font-weight: 500; }
        .controls p { color: #ffcccc !important; }
        .btn { background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%); text-shadow: 0 1px 2px rgba(0,0,0,0.5); }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 0, 0, 0.7); }
        .btn-secondary { background: #660000; color: #ffeeee !important; border: 2px solid #ff4444; }
        .output { background: #1a0000; border: 3px solid #ff4444; }
        .output h3 { color: #ffeeee !important; }
        .output p, .output div { color: #ffcccc !important; }
        .cell { background: #330000; border: 1px solid #ff4444; }
        .cell.fire { background: #ff0000; animation: flicker 0.5s infinite; }
        @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    </style>
    <div class="problem-container">
        <a href="index.html" class="back-button">‚Üê Back to Home</a>
        
        <div class="problem-header">
            <h1>üî• Problem 5: Forest Fire Escape Planner</h1>
            <p class="description">
                Plan a safe path for a hiker from start to exit before fire blocks all paths. Fire spreads each minute.
            </p>
        </div>

        <div class="controls">
            <h3>Forest Configuration (6√ó6 Grid)</h3>
            
            <div class="control-group">
                <label>Select Cell Type:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                    <button class="btn btn-secondary" onclick="setCellMode('clear')" id="mode-clear" style="background: white; color: #330000; border: 2px solid #ff4444;">
                        ‚¨ú Clear
                    </button>
                    <button class="btn btn-secondary" onclick="setCellMode('fire')" id="mode-fire" style="background: #ff4444; color: white;">
                        üî• Fire
                    </button>
                    <button class="btn btn-secondary" onclick="setCellMode('obstacle')" id="mode-obstacle" style="background: #2a0000; color: white;">
                        ‚¨õ Obstacle
                    </button>
                </div>
                <label>Click cells in the grid to place: <strong id="currentMode">Clear</strong></label>
                <div id="gridSetup" class="visualization"></div>
            </div>
            
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;">
                <button class="btn" onclick="findEscapePath()">Find Escape Path</button>
                <button class="btn" onclick="animateFireSpread()">Animate Fire Spread</button>
                <button class="btn btn-secondary" onclick="randomizeForest()">üé≤ Randomize</button>
                <button class="btn btn-secondary" onclick="resetForest()">Reset</button>
            </div>
        </div>

        <div id="output" class="output" style="display:none;">
            <h3>Escape Plan</h3>
            <div id="resultContent"></div>
            <div class="visualization">
                <div id="animationContainer"></div>
            </div>
            <div class="stats" id="stats"></div>
        </div>
    </div>

    <script>
        const SIZE = 6;
        let grid = [];
        let fireStart = [{x: 2, y: 2}, {x: 4, y: 4}];
        let start = {x: 0, y: 0};
        let exit = {x: 5, y: 5};
        let cellMode = 'clear'; // Current cell placement mode
        let animationInterval = null;

        function setCellMode(mode) {
            cellMode = mode;
            // Update button styles
            document.querySelectorAll('[id^="mode-"]').forEach(btn => {
                btn.style.opacity = '0.6';
                btn.style.transform = 'scale(1)';
            });
            const activeBtn = document.getElementById(`mode-${mode}`);
            activeBtn.style.opacity = '1';
            activeBtn.style.transform = 'scale(1.05)';
            
            // Update label
            const modeNames = {
                'clear': 'Clear',
                'fire': 'Fire üî•',
                'obstacle': 'Obstacle ‚¨õ'
            };
            document.getElementById('currentMode').textContent = modeNames[mode];
        }

        function initGrid() {
            grid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
            fireStart = [{x: 2, y: 2}, {x: 4, y: 4}];
            fireStart.forEach(f => grid[f.x][f.y] = 2); // 2 = fire
            grid[1][2] = grid[3][1] = 1; // obstacles
            renderGrid();
        }

        function randomizeForest() {
            grid = Array(SIZE).fill(null).map(() => Array(SIZE).fill(0));
            
            // Random obstacles (20-30% of cells)
            const obstacleCount = Math.floor(Math.random() * 7) + 5;
            for (let i = 0; i < obstacleCount; i++) {
                const x = Math.floor(Math.random() * SIZE);
                const y = Math.floor(Math.random() * SIZE);
                if ((x !== start.x || y !== start.y) && (x !== exit.x || y !== exit.y)) {
                    grid[x][y] = 1;
                }
            }
            
            // Random fire sources (2-4 cells)
            fireStart = [];
            const fireCount = Math.floor(Math.random() * 3) + 2;
            for (let i = 0; i < fireCount; i++) {
                const x = Math.floor(Math.random() * SIZE);
                const y = Math.floor(Math.random() * SIZE);
                if ((x !== start.x || y !== start.y) && (x !== exit.x || y !== exit.y) && grid[x][y] === 0) {
                    grid[x][y] = 2;
                    fireStart.push({x, y});
                }
            }
            
            renderGrid();
        }

        function renderGrid() {
            const container = document.getElementById('gridSetup');
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            gridDiv.innerHTML = '';
            
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = () => {
                        if ((i === start.x && j === start.y) || (i === exit.x && j === exit.y)) {
                            return; // Cannot change start/exit
                        }
                        
                        // Apply current mode
                        if (cellMode === 'clear') {
                            grid[i][j] = 0;
                        } else if (cellMode === 'fire') {
                            grid[i][j] = 2;
                            if (!fireStart.some(f => f.x === i && f.y === j)) {
                                fireStart.push({x: i, y: j});
                            }
                        } else if (cellMode === 'obstacle') {
                            grid[i][j] = 1;
                            // Remove from fire sources if it was fire
                            fireStart = fireStart.filter(f => f.x !== i || f.y !== j);
                        }
                        
                        renderGrid();
                    };
                    
                    if (i === start.x && j === start.y) {
                        cell.classList.add('start');
                        cell.textContent = 'S';
                        cell.style.fontSize = '20px';
                        cell.style.fontWeight = 'bold';
                    } else if (i === exit.x && j === exit.y) {
                        cell.classList.add('goal');
                        cell.textContent = 'E';
                        cell.style.fontSize = '20px';
                        cell.style.fontWeight = 'bold';
                    } else if (grid[i][j] === 1) {
                        cell.classList.add('obstacle');
                        cell.textContent = '‚¨õ';
                    } else if (grid[i][j] === 2) {
                        cell.classList.add('fire');
                        cell.textContent = 'üî•';
                    }
                    
                    gridDiv.appendChild(cell);
                }
            }
            container.innerHTML = '';
            container.appendChild(gridDiv);
        }

        function spreadFire(currentGrid) {
            const newGrid = currentGrid.map(row => [...row]);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    if (currentGrid[i][j] === 2) {
                        [[0,1],[1,0],[0,-1],[-1,0]].forEach(([dx,dy]) => {
                            const ni = i + dx, nj = j + dy;
                            if (ni >= 0 && ni < SIZE && nj >= 0 && nj < SIZE && currentGrid[ni][nj] === 0) {
                                newGrid[ni][nj] = 2;
                            }
                        });
                    }
                }
            }
            return newGrid;
        }

        function findEscapePath() {
            const fireTimeline = [grid.map(row => [...row])];
            for (let t = 0; t < 10; t++) {
                fireTimeline.push(spreadFire(fireTimeline[fireTimeline.length - 1]));
            }

            // BFS with time dimension
            const queue = [{pos: start, time: 0, path: [start]}];
            const visited = new Set([`${start.x},${start.y},0`]);

            while (queue.length > 0) {
                const {pos, time, path} = queue.shift();

                if (pos.x === exit.x && pos.y === exit.y) {
                    displayResult(path, time, fireTimeline);
                    return;
                }

                if (time + 1 >= fireTimeline.length) continue;

                [[0,1],[1,0],[0,-1],[-1,0]].forEach(([dx,dy]) => {
                    const nx = pos.x + dx, ny = pos.y + dy;
                    const nextTime = time + 1;
                    const key = `${nx},${ny},${nextTime}`;

                    if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && 
                        !visited.has(key) &&
                        fireTimeline[nextTime][nx][ny] === 0) {
                        visited.add(key);
                        queue.push({pos: {x: nx, y: ny}, time: nextTime, path: [...path, {x: nx, y: ny}]});
                    }
                });
            }

            // No path found - show why with visualization
            displayFailureReason(fireTimeline, visited);
        }

        function displayFailureReason(fireTimeline, visited) {
            const output = document.getElementById('output');
            const resultContent = document.getElementById('resultContent');
            const stats = document.getElementById('stats');
            const animationContainer = document.getElementById('animationContainer');
            
            output.style.display = 'block';
            
            // Analyze why path failed
            const reachableCells = new Set();
            visited.forEach(v => {
                const [x, y, t] = v.split(',').map(Number);
                reachableCells.add(`${x},${y}`);
            });
            
            const exitBlocked = !reachableCells.has(`${exit.x},${exit.y}`);
            const exitBurnedTime = findWhenExitBurned(fireTimeline);
            
            resultContent.innerHTML = `
                <div class="alert alert-error">
                    ‚úó No escape path found! 
                    ${exitBlocked ? 
                        `Exit became unreachable ${exitBurnedTime !== -1 ? `(burned at ${exitBurnedTime} min)` : '(blocked by obstacles)'}` : 
                        'Fire spread too fast - all paths blocked'}
                </div>
            `;

            stats.innerHTML = `
                <div class="stat-card">
                    <div class="label">Cells Explored</div>
                    <div class="value">${reachableCells.size}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Exit Status</div>
                    <div class="value" style="color: #ff4444;">${exitBurnedTime !== -1 ? `üî• ${exitBurnedTime}min` : 'üö´ Blocked'}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Fire Sources</div>
                    <div class="value">${fireStart.length}</div>
                </div>
            `;

            // Animate the failure - show how fire blocked the path
            animationContainer.innerHTML = '<h4>Fire Spread Analysis - Why Path Failed</h4>';
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            
            let step = 0;
            if (animationInterval) clearInterval(animationInterval);
            
            animationInterval = setInterval(() => {
                if (step >= fireTimeline.length) {
                    clearInterval(animationInterval);
                    return;
                }
                
                gridDiv.innerHTML = '';
                const currentGrid = fireTimeline[step];
                
                for (let i = 0; i < SIZE; i++) {
                    for (let j = 0; j < SIZE; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        const wasReachable = reachableCells.has(`${i},${j}`);
                        
                        if (i === start.x && j === start.y) {
                            cell.classList.add('start');
                            cell.textContent = 'S';
                            cell.style.fontSize = '20px';
                        } else if (i === exit.x && j === exit.y) {
                            if (currentGrid[i][j] === 2) {
                                cell.style.background = '#ff0000';
                                cell.textContent = 'üî•';
                                cell.title = 'Exit burned!';
                            } else {
                                cell.classList.add('goal');
                                cell.textContent = 'E';
                                cell.style.fontSize = '20px';
                            }
                        } else if (currentGrid[i][j] === 1) {
                            cell.classList.add('obstacle');
                            cell.textContent = '‚¨õ';
                        } else if (currentGrid[i][j] === 2) {
                            cell.classList.add('fire');
                            cell.textContent = 'üî•';
                        } else if (wasReachable && step === 0) {
                            cell.style.background = '#004400';
                            cell.style.opacity = '0.5';
                            cell.title = 'Explored area';
                        }
                        
                        gridDiv.appendChild(cell);
                    }
                }
                
                const timeInfo = document.createElement('p');
                timeInfo.style.margin = '10px 0';
                timeInfo.style.color = '#ffcccc';
                timeInfo.innerHTML = `<strong>Time: ${step} minutes</strong> - ${
                    step === exitBurnedTime ? 'üî• <strong>Exit blocked by fire!</strong>' :
                    step === 0 ? 'Green cells show areas you could reach' :
                    'Fire spreading...'
                }`;
                
                animationContainer.innerHTML = '<h4>Fire Spread Analysis - Why Path Failed</h4>';
                animationContainer.appendChild(timeInfo);
                animationContainer.appendChild(gridDiv);
                step++;
            }, 700);
        }

        function findWhenExitBurned(fireTimeline) {
            for (let t = 0; t < fireTimeline.length; t++) {
                if (fireTimeline[t][exit.x][exit.y] === 2) {
                    return t;
                }
            }
            return -1;
        }

        function displayResult(path, time, fireTimeline) {
            const output = document.getElementById('output');
            const resultContent = document.getElementById('resultContent');
            const stats = document.getElementById('stats');
            const animationContainer = document.getElementById('animationContainer');
            
            output.style.display = 'block';
            
            resultContent.innerHTML = `
                <div class="alert alert-success">‚úì Safe escape path found! Time to exit: ${time} minutes</div>
            `;

            stats.innerHTML = `
                <div class="stat-card">
                    <div class="label">Path Length</div>
                    <div class="value">${path.length}</div>
                </div>
                <div class="stat-card">
                    <div class="label">Time to Exit</div>
                    <div class="value">${time} min</div>
                </div>
                <div class="stat-card">
                    <div class="label">Safety Margin</div>
                    <div class="value">${10 - time} min</div>
                </div>
            `;

            // Animate the path
            animationContainer.innerHTML = '';
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            
            let step = 0;
            if (animationInterval) clearInterval(animationInterval);
            
            animationInterval = setInterval(() => {
                if (step >= time) {
                    clearInterval(animationInterval);
                    return;
                }
                
                gridDiv.innerHTML = '';
                const currentGrid = fireTimeline[step];
                
                // Check if current position on path has fire
                const currentPos = path[step];
                let pathTouchesFire = false;
                if (currentPos && currentGrid[currentPos.x][currentPos.y] === 2) {
                    pathTouchesFire = true;
                }
                
                for (let i = 0; i < SIZE; i++) {
                    for (let j = 0; j < SIZE; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        const onPath = path.some((p, idx) => p.x === i && p.y === j && idx <= step);
                        const isCurrentPos = currentPos && i === currentPos.x && j === currentPos.y;
                        
                        if (i === start.x && j === start.y) {
                            cell.classList.add('start');
                            cell.textContent = 'S';
                        } else if (i === exit.x && j === exit.y) {
                            cell.classList.add('goal');
                            cell.textContent = 'E';
                        } else if (isCurrentPos && pathTouchesFire) {
                            // Highlight the collision point
                            cell.style.background = '#ff0000';
                            cell.style.border = '3px solid yellow';
                            cell.style.animation = 'collisionPulse 0.5s infinite';
                            cell.textContent = 'üí•';
                            cell.title = 'Path blocked by fire!';
                        } else if (onPath) {
                            cell.classList.add('path');
                            cell.textContent = '‚úì';
                        } else if (currentGrid[i][j] === 1) {
                            cell.classList.add('obstacle');
                            cell.textContent = '‚¨õ';
                        } else if (currentGrid[i][j] === 2) {
                            cell.classList.add('fire');
                            cell.textContent = 'üî•';
                        }
                        
                        gridDiv.appendChild(cell);
                    }
                }
                
                const statusMsg = pathTouchesFire ? 
                    `<strong style="color: #ff4444;">‚ö†Ô∏è PATH BLOCKED! Fire reached the escape route at ${step} minutes</strong>` :
                    `Time: ${step} minutes`;
                animationContainer.innerHTML = `<h4>${statusMsg}</h4>`;
                animationContainer.appendChild(gridDiv);
                
                // Stop animation if path touches fire
                if (pathTouchesFire) {
                    clearInterval(animationInterval);
                    resultContent.innerHTML = `
                        <div class="alert" style="background: #ff4444; color: white;">
                            ‚ö†Ô∏è Escape Failed! Fire blocked the path at ${step} minutes. 
                            The route was safe when calculated, but fire spread faster than expected.
                        </div>
                    `;
                    return;
                }
                
                step++;
            }, 800);
        }

        function animateFireSpread() {
            const output = document.getElementById('output');
            const animationContainer = document.getElementById('animationContainer');
            
            output.style.display = 'block';
            document.getElementById('resultContent').innerHTML = `
                <div class="alert" style="background: #ffa500; color: white;">üî• Fire Spread Simulation</div>
            `;
            document.getElementById('stats').innerHTML = '';

            const fireTimeline = [grid.map(row => [...row])];
            for (let t = 0; t < 8; t++) {
                fireTimeline.push(spreadFire(fireTimeline[fireTimeline.length - 1]));
            }

            animationContainer.innerHTML = '';
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.style.gridTemplateColumns = `repeat(${SIZE}, 1fr)`;
            
            let step = 0;
            if (animationInterval) clearInterval(animationInterval);
            
            animationInterval = setInterval(() => {
                if (step >= fireTimeline.length) {
                    clearInterval(animationInterval);
                    return;
                }
                
                gridDiv.innerHTML = '';
                const currentGrid = fireTimeline[step];
                
                for (let i = 0; i < SIZE; i++) {
                    for (let j = 0; j < SIZE; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        if (i === start.x && j === start.y) {
                            cell.classList.add('start');
                            cell.textContent = 'S';
                        } else if (i === exit.x && j === exit.y) {
                            cell.classList.add('goal');
                            cell.textContent = 'E';
                        } else if (currentGrid[i][j] === 1) {
                            cell.classList.add('obstacle');
                            cell.textContent = '‚¨õ';
                        } else if (currentGrid[i][j] === 2) {
                            cell.classList.add('fire');
                            cell.textContent = 'üî•';
                        }
                        
                        gridDiv.appendChild(cell);
                    }
                }
                
                animationContainer.innerHTML = `<h4>Time: ${step} minutes</h4>`;
                animationContainer.appendChild(gridDiv);
                step++;
            }, 600);
        }

        function resetForest() {
            if (animationInterval) clearInterval(animationInterval);
            initGrid();
            document.getElementById('output').style.display = 'none';
            setCellMode('clear');
        }

        // Initialize
        initGrid();
        setCellMode('clear');
    </script>
</body>
</html>
